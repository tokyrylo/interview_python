# Як працює ООП під капотом 

Python реалізує об'єктно-орієнтоване програмування (ООП) через **класи та об'єкти**. Під капотом використовується система **метакласів**, **простір імен**, **атрибути класу та екземпляру, наслідування** та **денамічне зв'язкування методів**.

1. ***Що відбувається коли створюємо клас***

Коли ми оголошуємо клаc, Python виконує наступні кроки:

  1. **Виконує код класу** та створює простір імен для нього.
  2. **Використовує метаклас (`type`)**, щоб створити сам клас.
  3. **Зберігає клас у змінній** відповідно до його імен.

**Приклад:**

```python 
class MyClass:
  x = 10 # классовий атрибут 

  def hello(self):
    return "Hello, world!"
```

Python оброблює його так:

```python 
MyClass = type("MyClass", (object,), {"x": 10, "hello": lambda self: "Hello, world!"})
```
`type` **фактично створює клас!**

**Що відбувається**

 - `"MyClass"` - ім'я класу.
 - `(object,)` - кортеж батьківського класу.
 - `{...}` - словник атрибутів та методів класу.

**Висновок**

Клас у Python - це **об'єкт**, який створюється метакласом (`type`).


***2. Створення екземпляра класу***

Коли ми створюємо екземпляр (`obj = MyClass()`), Python проходить наступні етапи:

  1. Викликає `__new__`, щоб створити пам'ять для нового об'єкта.
  2. Викликає `__init__`, щоб ініціалізувати атрибути екземпляра.
  3. Повертає готовий об'єкт.

**Приклад:**

```python 
class MyClass:
  def __new__(cls, *args, **kwargs):
    print("__new__ викликається")
    instance = super().__new__(cls)
    return instance 

  def __init__(self, value):
    self.value = value 

obj = MyClass(42)
```

**Вивід:**

```python 
__new__ викликається 
__init__ викликається 
```

**Що відбувається під капотом?**

  1. `__new__` створює новий об'єкт.
  2. `__init__` встановлення значення атрибута.
  3. **Об'єкт повертається і зберігається в змінній `obj`**.

***3. Простір імен класу та об'єкту***

Python зберігає **атрибути класу** та **екземпляра** у **словниках (`dict`)**.

**Де зберігаються атрибути?**

```python 
class Demo:
  class_attr = "Я класовий атрибут"

  def __init__(self, value):
    self.instance_attr = value # Створюється в __dict__ екземпляра

obj = Demo(42)

print(Demo.__dict__) # Атрибути класу 
print(obj.__dict__) # Атрибути екземпляру 
```
**Вивід:**

```python 
{
  "class_attr": "Я классовий атрибут",
  "__module__": "__main__",
  "__init__": <function Demo.__init__ at 0x...>,
  ...
}
{
  "instance_attr": 42,
}
```

**Висновок:**
  - **Атрибути класу** зберігаються у `Demo.__dict__`.
  - **Атрибути екземпляру** зберігаються у `obj.__dict__`.


***4. Наслідування: Як Python шукає атрибути?***

Python використовує **MRO (Method Resolution Order)** для пошуку атрибутів у спадкових класах.

**Простий приклад наслідування:**

```python 
class A:
  x = "Клас А"


class B(A):
  pass 


obj = B()
print(obj.x) # Спочатку шукає у B, потім у A
```

**Вивід:**

```python
Клас А 
```

**MRO в деталях**

```python 
print(B.mro())
```

**Вивід:**

```python 
[<class "__main__.B">, <class "__main__.A">, <class "object">]
```
Python шукає атрибути **зліва направо** в `mro()`.

***5. Динамичне зв'язкування методів***:

Python **динамічно зв'язує методи** під час виклику.

**Як працює прив'язка методів?**

```python 
class Demo:
  def say_hello(self):
    return "Привет!"

obj = Demo()
print(obj.say_hello) # Зв'язаний метод 
print(Demo.say_hello) # Незв'язаний метод 
```

**Вивід:**

```python 
<bound method Demo.say_hello of <__main__.Demo object at 0x...>>
<function Demo.say_hello at 0x..>
```
***6. Метакласи: ***

Метакласи - це **класи, які створюють класи**.

**Створюємо власний метаклас:**

```python 
class Meta(type):
  def __new__(cls, name, bases, dct):
    print(f"Метаклас створює клас {name}")
    return super().__new__(cls, name, bases, dct)

class MyClass(metaclass=Meta):
  pass
```

**Вивід:**

```python 
Метаклас створює клас MyClass 
```
**Висновок:**

  1. Метаклас виконується перед створенням класу.
  2. `type` - це стандартний метаклас у Python.

***Підсумок: Як працює ООП у Python під капотом?***

| Етап | Що відюувається під капотом? |
| -------------- | --------------- |
| **1. Створення класу**  | `type(name, bases, dict)` |
| **2. Створення екземпляра**| Виклик `__new__` -> `__init__` |
| **3. Атрибути класу**| `Class.__dict__` |
| **4. Атрибути об'єкта**| `Object.__dict__` |
| **5. Пошук атрибутів** | `mro()` (Method Resolution Order) |
| **6. Наслідування** | Шукає методи у `mro()` |
| **7. Динамічне зв'язкування**| `obj.method` прив'язує метод |
| **8. Метакласи** | Клас створюється через `type` |


